# 事务在分布式环境下的问题

## 1、本地事务

### 1.1 事务的基本性质

事务具有ACID的特征:

+ 原子性：Atomic，一系列的操作整体不可拆分，要么同时成功，要么同时失败；
+ 一致性：Consistency，数据在事务前后，业务整体一致；
+ 隔离性：isolation，事务之间相互隔离
+ 持久性：durability，一旦事务成功，数据一定会保存到数据库中，即使发生宕机。

### 1.2 事务的隔离级别

+ **Read Uncommitted（读未提交）**

  一个事务可以读取另外一个事务未提交的数据，这种现象称之为**脏读**。
``
+ **Read Committed（读提交）**

  一个事务可以读取另一个事务已经提交的数据，多次读取可能会读到不同的结果，**这种现象称之为不可重复读**。

  Read Committed是Oracle和SQL Server的默认隔离级别。

+ **Repeatable Read（可重复读）**

  同一个事务中，select的结果总是和事务开始的状态一致，即保证事务内重复读到的结果具有一致性，因此称之为可重复读。

  但是会存在幻读，即一个事务在范围查询的时候，另外一个事务对该范围内的数据做出了修改，导致两次范围的查询结果不一致。

  MySQL的InnoDB存储引擎可以通过next-key locks机制来避免幻读。

+ **Serializable（串行化）**

  不同事务加锁串行执行，可以解决脏读、不可重复读、幻读等问题。

  MySQL的InnoDB存储引擎会给读操作隐式加一把读共享锁。

### 1.3 事务的传播行为

+ **PROPAGATION_REQUIRED**：如果当前没有事务，就会创建一个事务，如果当前存在事务，就加入该事务。【最常用】
+ **PROPAGATION_SUPPORTS**：支持当前事务，如果当前存在事务，加入该事务，当前不存在事务，则以非事务执行。
+ **PROPAGATION_MANDATORY**：支持当前事务，如果当前存在事务，加入该事务，当前不存在事务，就抛出异常。
+ **PROPAGATION_REQUIRES_NEW**：创建新事务，无论当前是否存在事务，都创建新的事务。
+ **PROPAGATION_NOT_SUPPORT**：以非事务的方式回字形操作，如果当前存在事务，就把当前事务挂起。
+ **PROPAGATION_NEVER**：以非事务方式执行，如果当前存在事务，抛出异常。
+ **PROPAGATION_NESTED**：如果当前存在事务，则在嵌套事务内执行。如果没有事务，则执行与PROPAGATION_REQUIRED类似操作。

### 1.4 SpringBoot中事务使用的一些坑

在同一个类中，编写两个方法，内部调用的时候，会导致事务传播设置失效，原因是没有用到代理对象。

解决办法：

1. **导入spring-boot-starter-aop**
2. **添加注解@EnableTransactionManagement(proxyTargetClass=true)**
3. **添加注解@EnableAspectJAutoProxy(exposeProxy=true)**：通过aspectj实现动态代理功能。
4. **通过AopContext.currentProxy()来调用方法**

```java
// 先通过AopContext.currentProxy();来获取当前对象
OrderServiceImpl orderService = (OrderServiceImpl)AopContext.currentProxy();
// 在通过当前对象来调用方法
orderService.a();
orderService.b();
```



## 2、 分布式事务

### 2.1 为什么会有分布式事务

与单体应用不同，分布式系统的不同服务之间通过网络调用来实现通信。由于网络具有不稳定性等因素，分布式系统中可能会产生机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠TCP、储存数据丢失等一些列问题。

在这种分布式系统下，如果保证能够以事务方式执行相比于单体应用难度大大提升，单体应用下使用的事务已经不能满足分布式环境下的场景，如下：

假如有三个系统，分别是订单系统、积分系统和库存系统。

![distribute_system](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/distribute_system.jpg)

订单系统在保存数据的时候，需要调用积分系统和库存系统一起保存，假设在订单系统中是通过判断积分系统和库存系统的调用是否成功，进而决定是否抛异常的方式来是实现订单系统事务的可靠性，就可能会出现以下问题了：

+ 订单系统调用积分系统成功，但是在接下来操作中，出现了异常，订单系统事务发送了回滚。此时积分系统已经改变，无法感知订单系统的错误，因此也无法回滚，订单系统和积分系统发生事务不一致。
+ 订单系统调用积分系统，积分系统执行成功，但由于网络等问题，成功的消息没能及时送达订单系统，订单系统认为积分系统操作失败，事务回滚。相当于积分系统执行成功，但是订单系统执行回滚，两系统发生不一致。

因此从上面可以看出来，传统的事务方式并不能解决分布式环境下的事务问题，这是就需要使用分布式事务来保证可靠性。

### 2.2 CAP定律和BASE理论

#### 2.2.1 CAP定理

CAP定理，指的是在一个分布式系统中：

+ **一致性（Consistency）**

  分布式系统中的所有数据备份，在同一时刻内是否具有相同的值。（等用于所有节点访问一份最新的数据副本）

+ **可用性（Availablity）**

  在集群中一部分节点故障之后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）

+ **分区容错性（Partition tolerance）**

  大多数分布式系统都是分布在多个子网络。每个只为了都叫一个区(partition)。分区容错是指区间通信可能失败。比如一台服务器在中国，另外一台在美国，他们位于不同区，可能无法通信。

**CAP原则是指，这三个要是最多只能同时实现两点，不可能三者兼顾。**

一般来说，分区容错是无法避免的，因此可以认为CAP中P总是成立的，剩下的A和C无法同时做到，所以一个系统要么是CP要么是AP。

分布式系统中要实现一致性并不是简单的，需要一些复杂算法的加持，如raft算法。

#### 2.2.2 面临的问题

对于大多数互联网应用场景，主机众多、部署分散，而且集群规模具有扩大的趋势，这时节点故障、网络故障是常态，这时往往需要保证服务可用性要达到99.9999999%，即保证可用性【A】，舍弃一致性【C】。

#### 2.2.3 BASE理论

BASE相当于是CAP的延伸，思想是即时无法做到强一致性(CAP一致性是强一致性)，但可以采用适当的弱一致性，即最终一致性。

BASE是指：

+ **基本可用(Basically Available)：**指分布式系统出现故障时，允许损失部分可用(如响应时间的可用、功能的可用)。
  + 响应时间的损失：正常情况下0.5s只能返回响应，但由于一些问题查询响应时间增加到了1-2s。
  + 功能上的损失：在双十一，为了保证系统稳定性，部分消费者可能会被引导到一个降级页面。
+ **软状态(Soft State)：**指运行系统存在中间状态，而该中间状态不会影响系统的整体可用性。分布式储存中一般一份数据会有多个副本，允许不同副本同步的延时是软状态的体现。MySQL replication也是一种体现。
+ **最终一致性（Eventual Consistency）**：最终一致性值系统中的所有数据副本经过一定时间之后，最终能够到达一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种情况。

#### 2.2.4 强、弱、最终一致性

客户端角度看，多线程并发访问，更新的数据在不同线程如何获取的不同策略，决定了不同的一致性。

对于关系型数据库，要求更新过的数据能被后继看到，是**强一致性**。

如果能够容忍后继部分或全部访问不到，则是**弱一致性**。

如果经过一段时间后要求能访问更新后的数据，则是**最终一致性**。

## 3、分布式事务的几种方案

### 3.1 2PC模式

数据库支持的2PC【2  Phase Commit 二阶段提交】，有叫做XA Transaction。

MySQL 从5.5版本开始支持，SQL Server 2005开始支持，Oracle 7开始支持。

其中，XA是一个两阶段提交协议，该协议分为以下两个阶段：

+ 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(Precommit)次操作，并反映是否可以提交；

+ 第二阶段：事务协调器要求每个数据库提交数据。

其中，如果任何一个数据库否决此次提交，那么所有数据库都会要求回滚它们在事务中的那部分信息。

![image-20210425124728069](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210425124728069.png)

XA 协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。

XA 性能不理想，特别是交易下单链路，往往并发量很高，XA无法满足高并发场景。

XA目前在商业数据库的支持也比较理想，在MySQL支持不是很理想，MySQL XA实现没有记录prepare阶段日志，主备切换导致主库和备库数据不一致。

许多NoSQL也没有支持XA，这让XA的应用场景变的狭隘。



### 3.2 柔性事务-TCC事务补偿方案

刚性事务：遵循ACID原则，强一致性。

柔性事务：遵循BASE理论，最终一致性。

与刚性事务不同，柔性事务运行一定时间内，不同节点数据不一致，但要求最终一致性。

![柔性事务](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1.png)

一阶段 prepare 行为：调用自定义的prepare逻辑。

二阶段 commit 行为：调用自定义的commit逻辑。

二阶段 rollback 行为：调用自定义的rollback逻辑。

所谓TCC模式，是指支持把自定义的分支事务纳入全局事务的管理中。

### 3.3 柔性事务-最大努力通知方案

按规律进行通知，不保证数据一定能通知成功，但会提供可查询操作接口进行核对。这种方案主要用在与第三方通讯时，比如：调用微信或支付宝后的支付结果通知。这种方案也是结合MQ进行实现，例如：通过MQ发送http请求，设置最大通知次数，达到通知次数后不再通知。

案例：银行通知、商户通知、支付宝支付成功异步回调。

### 3.4 柔性事务-可靠消息+最终一致性

实现：业务处理咋业务提交之前，先实时消息服务发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理访问在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。



## 4、高并发下的分布式事务

在高并发环境下，适合采用「可靠消息+最终一致性」的方式来实现分布式事务。

「可靠消息+最终一致性」重要前提是要保证消息可靠，如果不能保证消息的可靠，这个方案就是一个伪命题。

为了实现可靠消息，主要需要考虑以下几种情况：

1. 消息丢失：主要采用确认机制解决
2. 消息重复：接口幂等性处理，详情见项目中的「幂等性.md」
3. 消息积压：持久化

### 4.1 如何保证消息可靠性-消息丢失

消息丢失的原因可能有很多，但按照分类主要分为三类：

1. **消息发送出去，原因网络等原因没有道德服务器【客户端===>消息队列服务器】**
   + 做好容错方法(try-catch)，发送消息可能会因为网络失败，失败之后要有重试机制，可以记录在数据库采用定期扫描的方式重发
   + 做好日志记录，每个消息状态是否都被服务器收到都应该记录
   + 做好定期重发，如果消息没发送成功，定期去数据库扫描未成功消息重复

2. **消息抵达了Broker，但还没来得及持久化，服务器发生宕机【Broker===>队列】**
   + publisher也必须要加入确认机制回调，确认成的消息，修改数据库状态

3. **自动ACK状态下，消费者收到消息，但没来得及消费这个消息就发生宕机【队列===>消费者】**
   + 一定要开启手动ACK，消费成功才移除，失败或者没来得及处理就noACK并重新入队

> 消息持久化的表

```sql
CREATE TABLE `mq_message` (
  `message_id` char(32) NOT NULL COMMENT '消息标识',
  `content` text COMMENT '消息要保存的内容，可以考虑转换为json',
  `to_exchange` varchar(255) NOT NULL COMMENT 'Exchange',
  `routing_key` varchar(255) NOT NULL COMMENT 'routing_key',
  `class_type` varchar(255) NOT NULL,
  `message_status` int(11) DEFAULT '0' COMMENT '0-新建 1-已发送 2-错误抵达 3-成功抵达',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '更新时间'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
```

### 4.2 如何保证消息可靠性-消息重复

由于各种的原因，消息可能会被重复消费，下面根据其原因提前不同的解决方案：

1. **消息消费成功，事务已经提交，ack时，机器宕机，导致ack失败。Broker的消息重新由unack变为ready，并发送个其他消费者**
2. **消费失败，原因重试机制，自动又将消息发送出去**
   + 消费者的业务接口应该设计为幂等性的，如在扣除库存的时候有工作单的状态标志，合适的数据库SQL
   + 使用防重表，发送数据每一个都有业务的唯一标识，处理过的就不处理
   + 还可以根据RabbitMQ消息(Message)中的redelivered字段，判断是否是重新投递过来的

### 4.3 如何保证消息可靠性-消息积压

由于各种原因，消息不能及时被处理，可能会导致消息的积压：

1. **消费者宕机积压**
2. **消费者消费能力不足积压**
3. **发送者发送流量太大**
   + 上线更多消费者，进行正常消费
   + 上线专门的队列消费服务，将消息先批量取出来，保存在数据库，离线慢慢处理



## 补充

### Raft算法

http://thesecretlivesofdata.com/raft/

https://raft.github.io/

https://raft.github.io/raft.pdf

在raft算法中，每个节点就要三种状态：Follower(跟随者)、Candidate(候选人)、Leader(领导)

**【领导选举阶段(Leader Election)】**

+ 所有的节点一开始都是Follower

+ 如果一段时间内没有收到来自Leader的心跳，他们就会变成Candidate
+ Candidate会发送消息，让其他节点给它投票(Votes)
+ 其他节点会响应Candidate的投票
+ 如果Candidate收到了系统中大多数节点的投票，就会成为Leader

**【日志复制阶段(Log Replication)】**

+ 之后系统的所有改变通过Leader来实现

+ 每个客户端的修改请求都会别添加到日志条目中
+ 当一个客户端修改请求发送到Leader节点，修改被记录在条目中且处于uncommitted状态，此时其他客户端读不到该修改
+ 之后，Leader节点通过心跳将记录了修改的条目发送给所有的Follower
+ 只有大多数的Follower响应收到之后，这次修改才算成功，即committed，此时该修改可以被其他客户端读取到

【Leader Election详细过程】

Raft通过两个超时时间来控制选举过程(elections)

第一个超时时间是election timeout，指「Follower等待到变成Candidate」的这段时间；election timeout被随机为 150ms - 300ms之间。

在election timeout之后，如果没有收到Leader心跳，Follower将变成Candidate，同时开启一个新的选举周期（election term=1）。

之后该节点发送投票请求个其他节点，让其他节点投票个自己，其他节点收到之后，会重置自己的election timeout，同时会响应响应Candidate的请求。

Candidate收到了大部分的票之后就会变成Leader，然后给其他节点发送心跳，Follower收到之后会响应Leader。

心跳的间隔时间称之为 heartbeat timeout。

如果Leader由于各种原因不可以，在election timeout之后会有新的一轮选举，这时选举周期递增（election term=2）。

如果在选举过程中，存在两个Candidate的票数一致，就会重新投票，这个过程中选举周期会一直递增。

【Log Replication详细过程】

client将修改发送到Leader，Leader会在接下来的心跳将这些修改发送给其他节点

其他节点收到之后，将会响应Leader，Leader在收到大多数的响应之后就会确认修改成功，并响应给client

如果系统由于网络等问题，发生了分区情况：（A区有3个节点，B区有2个节点）

这时两个区域，只能是在具有大多数节点的区间能够成功选举出Leader

其他区域由于少用(1/2)，不符合大多数的选举原则，无法选出Leader，这个区域也处于不可用

如果刚好两个区域都是(1/2)，两个区域都无法选举出候选者，两个区域都处于不可用

如果是其中一个区域选举出来的情况，这个区域继续接受请求，如果心跳，并保存。

后来某个时刻，另外一个区域与当前区域也可以通信了，此时数据的同步以term为准。

